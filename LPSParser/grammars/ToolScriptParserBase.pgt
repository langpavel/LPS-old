##TEMPLATE-NAME 'Sablona ToolScriptParserBase.cs'
##LANGUAGE 'C#'
##ENGINE-NAME 'ToolScript'
##AUTHOR 'Pavel Lang'
##FILE-EXTENSION 'cs'
##NOTES
Sablona ToolScriptParserBase.cs
##END-NOTES
##ID-CASE ProperCase
using com.calitha.commons;
using com.calitha.goldparser;
using com.calitha.goldparser.lalr;
using System;
using System.Collections;
using System.IO;
using System.Reflection;
using System.Runtime.Serialization;
using LPS.ToolScript.Tokens;

namespace LPS.ToolScript
{

    /// <sumarry>Symboly</summary>
    public enum Symbols : int
    {
		#region Terminaly
##SYMBOLS
##DELIMITER ','   
        /// <summary>
        /// <para>Symbol: %Name.XML%</para>
        /// <para><c>%Description.XML%</c></para>
        /// </summary>
        %ID% = %Value%,

##END-SYMBOLS
		#endregion

		#region Neterminaly
##RULES
##DELIMITER ','   
        /// <summary>
        /// <para>Pravidlo: %Name.XML%</para>
        /// <para><c>%Description.XML%</c></para>
        /// </summary>
        Rule%ID% = ToolScriptParserBase.RulesOffset + %Value%%Delimiter%

##END-RULES
    };
    #endregion

	#region ToolScriptParserBase
    public abstract class ToolScriptParserBase
    {
		public const int RulesOffset = 10000;
        private LALRParser parser;

        public ToolScriptParserBase()
        {
        	using(Stream s = Assembly.GetExecutingAssembly().GetManifestResourceStream("toolscript.cgt"))
        		Init(s);
        }

        private void Init(Stream stream)
        {
            CGTReader reader = new CGTReader(stream);
            parser = reader.CreateNewParser();
            parser.TrimReductions = false;
            parser.StoreTokens = LALRParser.StoreTokensMode.NoUserObject;

            parser.OnTokenError += new LALRParser.TokenErrorHandler(TokenErrorEvent);
            parser.OnParseError += new LALRParser.ParseErrorHandler(ParseErrorEvent);
        }

        public virtual object Parse(string source)
        {
            NonterminalToken token = parser.Parse(source);
            if (token == null)
	            return null;
	        return CreateObject(token);
        }

        protected virtual object CreateObject(Token token)
        {
            if (token is TerminalToken)
                return CreateObjectFromTerminal((TerminalToken)token);
            else
                return CreateObjectFromNonterminal((NonterminalToken)token);
        }

		#region ToolScriptParserBase.Symboly
##SYMBOLS
        /// <summary>
        /// <para>Symbol: %Name.XML%</para>
        /// <para><c>%Description.XML%</c></para>
        /// </summary>
        protected virtual object CreateTerminal%ID%(TerminalToken token)
        {
        	return token;
        }

##END-SYMBOLS
		#endregion

        protected virtual object CreateObjectFromTerminal(TerminalToken token)
        {
            switch (token.Symbol.Id)
            {
##SYMBOLS
                case (int)Symbols.%ID%: //%Description%
                	return CreateTerminal%ID%(token);

##END-SYMBOLS
            }
            throw new SymbolException("Unknown symbol");
        }

		#region ToolScriptParserBase.Pravidla
##RULES
        /// <summary>
        /// <para>Pravidlo: %Name.XML%</para>
        /// <para><c>%Description.XML%</c></para>
        /// </summary>
        protected virtual object CreateNonterminal%ID%(NonterminalToken token)
        {
        	if(token.Tokens.Length == 0)
        		return null;
        	if(token.Tokens.Length == 1)
	        	return CreateObject(token.Tokens[0]);
        	ArrayList result = new ArrayList();
        	foreach(Token tok in token.Tokens)
        		result.Add(CreateObject(tok));
        	return result.ToArray();
        }
        
##END-RULES
		#endregion

        protected virtual object CreateObjectFromNonterminal(NonterminalToken token)
        {
            switch (token.Rule.Id + ToolScriptParserBase.RulesOffset)
            {
##RULES
                case (int)Symbols.Rule%ID%: //%Description%
                	return CreateNonterminal%ID%(token);
##END-RULES
            }
            throw new RuleException("Unknown rule");
        }

        private void TokenErrorEvent(LALRParser parser, TokenErrorEventArgs args)
        {
            string message = "Token error with input: '"+args.Token.ToString()+"'";
            Log.Error(message);
        }

        private void ParseErrorEvent(LALRParser parser, ParseErrorEventArgs args)
        {
            string message = "Parse error caused by token: '"+args.UnexpectedToken.ToString()+"'";
            Log.Error(message);
        }

		#endregion

    }
}
